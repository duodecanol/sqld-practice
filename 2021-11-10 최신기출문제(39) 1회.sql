/**************************************************************
    PART 05 --- SQLD 최신기출문제
    SQLD 최신기출문제 (39회) 1회       p.304
***************************************************************/

/*******************************
    14. UNION ALL 다음에 MINUS
    하면 어떤 결과가???     p.310
********************************/

CREATE TABLE TESTTBL1_39_14 (A NUMBER(10));
CREATE TABLE TESTTBL2_39_14 (A NUMBER(10));
CREATE TABLE TESTTBL3_39_14 (A NUMBER(10));

INSERT INTO TESTTBL1_39_14 VALUES (1);
INSERT INTO TESTTBL1_39_14 VALUES (2);
INSERT INTO TESTTBL1_39_14 VALUES (3);
INSERT INTO TESTTBL1_39_14 VALUES (4);
INSERT INTO TESTTBL1_39_14 VALUES (5);
INSERT INTO TESTTBL1_39_14 VALUES (6);

INSERT INTO TESTTBL2_39_14 VALUES (3);
INSERT INTO TESTTBL2_39_14 VALUES (7);
INSERT INTO TESTTBL2_39_14 VALUES (8);

INSERT INTO TESTTBL3_39_14 VALUES (4);
INSERT INTO TESTTBL3_39_14 VALUES (5);
INSERT INTO TESTTBL3_39_14 VALUES (6);

SELECT * FROM TESTTBL1_39_14
    UNION ALL
SELECT * FROM TESTTBL2_39_14
    MINUS
SELECT * FROM TESTTBL3_39_14;

/*******************************
    18. CUBE를 다른 방식으로 표현하기 p.311
********************************/
SELECT DEPTNO, JOB FROM EMP
GROUP BY CUBE(DEPTNO, JOB);

-- 2번보기
SELECT DEPTNO, JOB FROM EMP
GROUP BY GROUPING SETS(DEPTNO, JOB, (DEPTNO, JOB), NULL);

SELECT DEPTNO FROM EMP
GROUP BY DEPTNO;

/*******************************
    26. GROUP BY와 ORDER BY의 결합시 결과는?
********************************/

CREATE TABLE TESTTBL_39_26 (ID NUMBER(10));
INSERT INTO TESTTBL_39_26 VALUES (1000);
INSERT INTO TESTTBL_39_26 VALUES (1000);
INSERT INTO TESTTBL_39_26 VALUES (1000);
INSERT INTO TESTTBL_39_26 VALUES (3000);
INSERT INTO TESTTBL_39_26 VALUES (3000);
INSERT INTO TESTTBL_39_26 VALUES (4000);
INSERT INTO TESTTBL_39_26 VALUES (9999);
INSERT INTO TESTTBL_39_26 VALUES (9999);

SELECT * FROM TESTTBL_39_26;

-- 문제를 잘 읽어보면 그루핑을 하되 카운트가 2개인 것들만 추린다.
-- 두개 이상으로 잘못 읽어서 틀린 케이스.
SELECT ID FROM TESTTBL_39_26
GROUP BY ID HAVING COUNT(*) = 2;

SELECT ID FROM TESTTBL_39_26
GROUP BY ID HAVING COUNT(*) = 2
ORDER BY (CASE WHEN ID=1000 THEN 0 ELSE ID END); -- 1000은 집계되지 않음. 따라서 데이터 순서대로

SELECT ID FROM TESTTBL_39_26
GROUP BY ID HAVING COUNT(*) = 2
ORDER BY (DECODE(ID, 1000, 0, ID)); -- CASE WHEN...을 DECODE로 표현


SELECT * FROM EMP
WHERE EMPNO > 0
ORDER BY EMPNO DESC;

/*******************************
    35. 특정 하나의 값에 대한 자신의 상위 KPI를 검색하는 SQL문
********************************/
CREATE TABLE KPIPOOL_39_35 (SUBKPI NUMBER(2), KPINAME VARCHAR2(50), MAINKPI NUMBER(2));
INSERT INTO KPIPOOL_39_35 VALUES (10, '고객만족도', 0);
INSERT INTO KPIPOOL_39_35 VALUES (20, '콜센터만족도', 10);
INSERT INTO KPIPOOL_39_35 VALUES (30, '불만건수', 20);
INSERT INTO KPIPOOL_39_35 VALUES (40, '대기시간', 30);
INSERT INTO KPIPOOL_39_35 VALUES (50, '건의건수', 40);
COMMIT;
SELECT LEVEL, KPIPOOL_39_35 .* FROM KPIPOOL_39_35 
START WITH MAINKPI = 0
CONNECT BY PRIOR SUBKPI = MAINKPI;

SELECT LEVEL, KPIPOOL_39_35 .* FROM KPIPOOL_39_35 
WHERE SUBKPI = 30
START WITH MAINKPI = 0
CONNECT BY PRIOR SUBKPI = MAINKPI;

/*******************************
    38. 내일 날짜를 조회하는 쿼리
********************************/
SELECT TO_CHAR(SYSDATE + 1, 'YYYY-MM-DD') TOMORROW FROM DUAL;

/*******************************
    43. 정규화 수행
********************************/

/*******************************
    49. 같은 테이블 두개 조인한 결과
********************************/
CREATE TABLE TESTTBL1_39_49 (C1 NUMBER(1), C2 NUMBER(1), C3 NUMBER(1));
CREATE TABLE TESTTBL2_39_49 (C1 NUMBER(1), C2 NUMBER(1), C3 NUMBER(1));

INSERT INTO TESTTBL1_39_49 VALUES (1, 1, 3);
INSERT INTO TESTTBL1_39_49 VALUES (1, 2, 3);
INSERT INTO TESTTBL1_39_49 VALUES (2, 1, 3);
INSERT INTO TESTTBL1_39_49 VALUES (3, 1, 3);
INSERT INTO TESTTBL1_39_49 VALUES (3, 2, 3);

INSERT INTO TESTTBL2_39_49 (C1, C2, C3)
SELECT * FROM TESTTBL1_39_49;
COMMIT;

SELECT * FROM TESTTBL1_39_49;
SELECT * FROM TESTTBL2_39_49;

SELECT * FROM TESTTBL1_39_49, TESTTBL2_39_49
;
SELECT * FROM TESTTBL1_39_49 A, TESTTBL2_39_49 B -- CARTESIAN
WHERE A.C1 = B.C1;

SELECT * FROM TESTTBL1_39_49 A CROSS JOIN TESTTBL2_39_49 B -- CARTESIAN
WHERE A.C1 = B.C1;

SELECT * FROM TESTTBL1_39_49 A INNER JOIN TESTTBL2_39_49 B -- SAME RESULT
ON A.C1 = B.C1;

SELECT * FROM TESTTBL1_39_49 A NATURAL JOIN TESTTBL2_39_49 B; -- ORIGINAL TABLE
