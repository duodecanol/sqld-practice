
# Section 03. SQL OPTIMIZATION PRINCIPLES

## 1. Optimizer and execution plan - `p.212`

## 2. Optimizer 종류

## 3. INDEX

<font color="blue"> RDBMS의 검색 속도를 높이기 위해 사용하는 기술이다. </font>

인덱스 키를 기준으로 정렬된 데이터를 메모리에 파일 형태로 생성한다. 이후 우선적으로 인덱스 파일을 검색하기 때문에, 테이블 풀스캔을 하지 않아서 검색 성능이 향상된다.

#### 인덱스 사용 장점

- 데이터 검색 속도 향상
    - 미리 정렬된 데이터 내에서 탐색하므로 SELECT 쿼리 속도가 향상된다

- 전반적인 시스템 성능 향상

    - 인덱스를 사용하면, 디스크 I/O가 줄어들어 **시스템 부하**가 감소한다. 

#### 인덱스 사용 단점

- 레코드 삽입/수정/삭제 성능 감소

    - 데이터 변경 작업이 빈번한 경우, 인덱스 파일도 같이 수정해주어야 하므로 부하가 증가한다.

- 추가적인 공간 필요

    - 인덱스를 생성하기 위해서 DB의 약 10% 내외의 저장 공간이 필요하다. (저장 성능을 희생하고 읽기 속도를 높이는 기능이다.)

- 인덱스 생성 시 많은 시간 소요

#### 인덱스 선정 기준

- 카디널리티(Cardinality)가 가장 높은 것
    - 인덱스 키가 여러개일 경우, 카디널리티 높음 -> 낮음 순서로 구성한다.
    - Cardinality가 높다 => Attribute 값들이 보다 Unique하다

#### 인덱스의 종류


##### (1) 클러스터형 인덱스 (Clustered Index)

물리적으로 행을 재배열한다. 인덱스로 정렬된 순서가 데이터 조회 시의 실제 순서와 일치한다.

실제 DB의 데이터 파일에 정렬이 된 상태가 디스크에 저장이 된다. (인덱스 자체가 데이터)

- 테이블 당 1 개만 생성 가능하다.
- 인덱스 페이지 용량이 논 클러스터보다 작다. 
    - leaf 레벨의 인덱스 테이블이 별도로 필요 없기 때문이다.
- 물리적으로 정렬되어 있으므로, 논 클러스터에 비해 IO가 빠르다.
- 영어사전과 비슷한 개념이다. 
- 행 데이터를 인덱스로 지정한 열에 맞춰 자동정렬한다.

##### 2) 논클러스터형 인덱스(Non-clustered Index)

물리적으로 재배열 하지 않는다. 인덱스 테이블을 별도로 생성하여 데이터를 정렬한다.

- 테이블 당 여러개를 생성 가능하다.
- 클러스터 페이지보다 용량이 크다.
- 일반 책의 찾아보기와 비슷한 개념
- 인덱스 자체가 데이터가 아니라 인덱스가 가리키는 것이 데이터 범위 당 3% 이내일 때 효율적이다.



출처: https://ryusae.tistory.com/13 [초보자 전용 마을]



## 4. EXECUTION PLAN - `p.220`

## 5. OPTIMIZER JOIN    -      `p.222`

### Nested Loop Join : NS Join
- RANDOM ACCESS

### Sort Merge Join : SM Join
- MERGE AND JOIN

### Hash Join
- EQUI JOIN 시에만 사용
- 삽입 삭제 탐색이 매우 빠름 -  hashing
- CPU 연산이 많다 - Hash function으로 주소 계산하고 그 주소로 테이블 조인
- 별도 메모리공간

### 