
/**************************************************************
    PART 05 --- SQLD 최신기출문제
    SQLD 최신기출문제 (37회) 3회       p.347
***************************************************************/

/*******************************
    14. MERGE TABLE 명령어
********************************/
DROP TABLE TT_TEST1;

CREATE TABLE TT_TEST1 (COL1 CHAR(3), COL2 CHAR(3), COL3 NUMBER(1));
CREATE TABLE TT_TEST2 (COL1 CHAR(3), COL2 CHAR(3), COL3 NUMBER(1));

INSERT INTO TT_TEST1 VALUES ('A', 'X', 1);
INSERT INTO TT_TEST1 VALUES ('B', 'Y', 2);
INSERT INTO TT_TEST1 VALUES ('C', 'Z', 3);

INSERT INTO TT_TEST2 VALUES ('A', 'X', 1);
INSERT INTO TT_TEST2 VALUES ('B', 'Y', 2);
INSERT INTO TT_TEST2 VALUES ('C', 'Z', 3);
INSERT INTO TT_TEST2 VALUES ('D', '가', 4);
INSERT INTO TT_TEST2 VALUES ('E', '나', 5);

COMMIT;
SELECT * FROM TT_TEST1;
SELECT * FROM TT_TEST2;

SELECT * FROM TT_TEST1 A RIGHT OUTER JOIN TT_TEST2 B 
ON A.COL1= B.COL1;

MERGE INTO TT_TEST1
USING TT_TEST2
    ON (TT_TEST1.COL1 = TT_TEST2.COL1)
WHEN MATCHED THEN
    UPDATE SET TT_TEST1.COL3 = 4
        WHERE TT_TEST1.COL3 = 2
    DELETE WHERE TT_TEST1.COL3 <= 2
WHEN NOT MATCHED THEN
    INSERT (TT_TEST1.COL1, TT_TEST1.COL2, TT_TEST1.COL3)
    VALUES (TT_TEST2.COL1, TT_TEST2.COL2, TT_TEST2.COL3);

MERGE INTO TT_TEST1
USING TT_TEST2
    ON (TT_TEST1.COL1 = TT_TEST2.COL1)
WHEN MATCHED THEN
    UPDATE SET TT_TEST1.COL3 = 4
        WHERE TT_TEST1.COL3 = 2
--    DELETE WHERE TT_TEST1.COL3 <= 2  위 결과와 같음
WHEN NOT MATCHED THEN
    INSERT (TT_TEST1.COL1, TT_TEST1.COL2, TT_TEST1.COL3)
    VALUES (TT_TEST2.COL1, TT_TEST2.COL2, TT_TEST2.COL3);

MERGE INTO TT_TEST1
USING TT_TEST2
    ON (TT_TEST1.COL1 = TT_TEST2.COL1)
WHEN MATCHED THEN
    UPDATE SET TT_TEST1.COL3 = 4
        WHERE TT_TEST1.COL3 = 2
    DELETE WHERE TT_TEST1.COL3 <= 2 OR TT_TEST2.COL3 <= 2 -- B가 있는 행이 사라짐
WHEN NOT MATCHED THEN
    INSERT (TT_TEST1.COL1, TT_TEST1.COL2, TT_TEST1.COL3)
    VALUES (TT_TEST2.COL1, TT_TEST2.COL2, TT_TEST2.COL3);
ROLLBACK;

/*******************************
    16. CONNECT BY 우두머리 제거
********************************/

SELECT * FROM EMP;
SELECT EMPNO, ENAME, MGR FROM EMP
WHERE EMPNO IN (7839, 7698, 7654);

SELECT LPAD('**', (LEVEL-1) * 2, ' ') || EMPNO AS EMP, ENAME
FROM (SELECT EMPNO, ENAME, MGR FROM EMP
        WHERE EMPNO IN (7839, 7698, 7654))
START WITH EMPNO = 7654
CONNECT BY EMPNO = PRIOR MGR;

SELECT LPAD('**', (LEVEL-1) * 2, ' ') || EMPNO AS EMP, ENAME
FROM (SELECT EMPNO, ENAME, MGR FROM EMP
        WHERE EMPNO IN (7839, 7698, 7654))
WHERE EMPNO <> 7654 -- 위 결과에서 해당번호만 빼고 출력
START WITH EMPNO = 7654
CONNECT BY EMPNO = PRIOR MGR;

SELECT LPAD('**', (LEVEL-1) * 2, ' ') || EMPNO AS EMP, ENAME
FROM (SELECT EMPNO, ENAME, MGR FROM EMP
        WHERE EMPNO IN (7839, 7698, 7654))
WHERE EMPNO <> 7698 -- 위 결과에서 해당번호만 빼고 출력 ... WHERE로 중간번호가 없어도 연결이 실패하지 않는다.
START WITH EMPNO = 7654
CONNECT BY EMPNO = PRIOR MGR;

SELECT DECODE(0, 1, 2, NULL) FROM DUAL;
    IF 0 == 1 THEN 2
    ELSE NULL
SELECT DECODE('A', 'B', 'C', NULL) FROM DUAL;
    IF A == B THEN C
    ELSE NULL
    
SAVEPOINT SV1;
SAVE POINT SV1;

/*******************************
    29. NOT IN NULL p.134
    
    https://stackoverflow.com/questions/129077/null-values-inside-not-in-clause
    https://stackoverflow.com/questions/60788886/the-not-in-with-null-values-dilemma-in-oracle-sql
********************************/
--DROP TABLE TT_TEST29_2;
CREATE TABLE TT_TEST29_1 (COL NUMBER(2));
CREATE TABLE TT_TEST29_2 (COL NUMBER(2));
INSERT INTO TT_TEST29_1 VALUES (1);
INSERT INTO TT_TEST29_1 VALUES (2);
INSERT INTO TT_TEST29_1 VALUES (3);
INSERT INTO TT_TEST29_1 VALUES (4);

INSERT INTO TT_TEST29_2 VALUES (2);
INSERT INTO TT_TEST29_2 VALUES (NULL);
-------------------------------------
SELECT * FROM TT_TEST29_1;
SELECT * FROM TT_TEST29_2;

SELECT COUNT(*) FROM TT_TEST29_1 A
WHERE A.COL NOT IN (SELECT B.COL FROM TT_TEST29_2 B);

SELECT * FROM TT_TEST29_1 A
WHERE A.COL IN (SELECT COL FROM TT_TEST29_2);

SELECT 1 FROM DUAL WHERE 1 NOT IN (2, 3); -- 1은 2, 3중에 없으니 TRUE
SELECT 1 FROM DUAL WHERE 1 NOT IN (2, NULL); -- NOT IN일때는 NULL을 제외하고서 TRUE이지만 결과는 FALSE
SELECT 1 FROM DUAL WHERE 1 NOT IN (1, NULL); 
SELECT 1 FROM DUAL WHERE 1 IN (2, 3);
SELECT 1 FROM DUAL WHERE 1 IN (2, 1);
SELECT 1 FROM DUAL WHERE 1 IN (1, NULL); -- IN일때는 NULL 무시하고 남은 값중에서 일치하면 TRUE


1  - 2, N  => 1
2  - 2, N
3  - 2, N
4  - 2, N

/*******************************
    40. ORDER BY 사용 불가 p.365
********************************/

SELECT EMPNO, ENAME, JOB FROM EMP
ORDER BY 3;  -- 여기서 숫자는 컬럼 넘버

SELECT EMPNO, ENAME, JOB FROM EMP
ORDER BY 4; -- 컬럼이 세개인데 4를 지정해 오류.

SELECT JOB, COUNT(*) AS ROWCNT
FROM EMP
GROUP BY JOB
ORDER BY CNT DESC;

SELECT JOB, COUNT(*) AS ROWCNT
FROM EMP
GROUP BY JOB
ORDER BY ROWCNT DESC;